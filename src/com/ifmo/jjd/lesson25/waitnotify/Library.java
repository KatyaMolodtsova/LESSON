package com.ifmo.jjd.lesson25.waitnotify;

import java.util.ArrayList;

public class Library {
    private ArrayList<Book> books = new ArrayList<>(6);

    // добавление в хранилище объекта, не более 6 книг
    public synchronized void putBook(Book book) throws InterruptedException {
        // цикл нужен для того, чтобы
        // поток при произвольном просыпании, снова уснул
        // либо, если поток будет разбужен другим потоком проверить условие
        while (books.size() > 5){
            System.out.println("put поток уходит в ожидание...");
            wait();
        }

        books.add(new Book());
        System.out.println("Книга добавлена, всего книг: " + books.size());
        notify(); // [put1, get1] - любой поток из wait set
        // из-за неконтролируемости может привести к простою ресурсов, будут просыпаться и засыпать не те потоки
        // 2 проблема, что нет очередности
        // нет никакой гарантии, что проснется то, что нужно
    }

    public Book getBook() throws InterruptedException {
        while (books.size() == 0){
            System.out.println("get поток уходит в ожидание");
            wait();
        }
        Book book = books.remove(0);
        System.out.println("Удалена книга, всего книг: " + books.size());
        notify();
        return book;
    }
}

// один из вариантов решения этой проблемы
// wait / notify
// должны быть вызваны или в synchronized блоке или в synchronized методе, иначе будет ошибка
// есть библиотека. потоки добавляют объекты в хранилище и потоки удаляют объекты из хранилища
// putThreads -> (должны ждать, если в хранилище 6 объектов)
// (у объекта есть wait set, для тех, кто ждет)
// library: wait set [put1, put2]
// -> getThreads(если объектов в хранилище нет, то поток должен ждать, пока они появялся)

// put1 -> library.wait() - метод wait приостанавливает работу потока до тех пор, пока поток не будет разбужен,
// например, вызовом метода notify, помещает в wait set

// put2 -> library.wait()

// поток может быть разбужен
// get1 -> library.notify() -  необходимо разбудить какой-то поток, из wait set рандомный поток убирается и
// передается в очередь планировщику потока
// get2 -> library.notifyAll() - все потоки будут удалены из wait set и передаются планировщику потоков и
// планировщик решает, в какой последовательности их запустить
// put3 -> library.wait(1000) - поток просыпается сам, так как не был разбужет методом notify
// и прошло указанное количество милисекунд
// put4 -> library.wait() - проснулся сам, тк произошло случайное пробуждение потока
// любой поток может проснуться сам по себе и продложить работу по неизвестным причинам


class Book{}
